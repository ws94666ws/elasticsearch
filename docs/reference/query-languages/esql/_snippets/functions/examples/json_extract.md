% This is generated by ESQL's AbstractFunctionTestCase. Do not edit it. See ../README.md for how to regenerate it.

## Examples

```esql
ROW log = """{"severity":"ERROR","body":"Payment processing failed"}"""
| EVAL severity = JSON_EXTRACT(log, "severity")
```

| log:keyword | severity:keyword |
| --- | --- |
| "{""severity"":""ERROR"",""body"":""Payment processing failed""}" | ERROR |

The `$` prefix is optional — this query produces the same result as the previous example:

```esql
ROW log = """{"severity":"ERROR","body":"Payment processing failed"}"""
| EVAL severity = JSON_EXTRACT(log, "$.severity")
```

| log:keyword | severity:keyword |
| --- | --- |
| "{""severity"":""ERROR"",""body"":""Payment processing failed""}" | ERROR |

To extract a deeply nested value, use dot-notation:

```esql
ROW log = """{"resource":{"service":{"name":"order-service"}}}"""
| EVAL svc = JSON_EXTRACT(log, "resource.service.name")
```

| log:keyword | svc:keyword |
| --- | --- |
| "{""resource"":{""service"":{""name"":""order-service""}}}" | order-service |

Keys that contain dots (common in OpenTelemetry semantic conventions) require quoted bracket notation — here `service.name` is a single key, not a nested path:

```esql
FROM json_logs
| EVAL svc = JSON_EXTRACT(payload, "resource['service.name']")
| KEEP @timestamp, source, svc
| SORT @timestamp
| LIMIT 3
```

| @timestamp:date | source:keyword | svc:keyword |
| --- | --- | --- |
| 2024-10-01T12:00:00.000Z | api-gateway | api-gateway |
| 2024-10-01T12:01:00.000Z | user-service | user-service |
| 2024-10-01T12:02:00.000Z | auth-service | auth-service |

Array indices can be combined with dot notation to navigate arrays of objects:

```esql
ROW log = """{"spans":[{"name":"auth","duration":12},{"name":"db-query","duration":45}]}"""
| EVAL span = JSON_EXTRACT(log, "spans[1].name")
```

| log:keyword | span:keyword |
| --- | --- |
| "{""spans"":[{""name"":""auth"",""duration"":12},{""name"":""db-query"",""duration"":45}]}" | db-query |

When the extracted value is an object or array, it is returned as a JSON string:

```esql
ROW log = """{"resource":{"service.name":"api-gateway","host.name":"api-server-03"},"severity":"INFO"}"""
| EVAL resource = JSON_EXTRACT(log, "resource")
```

| log:keyword | resource:keyword |
| --- | --- |
| "{""resource"":{""service.name"":""api-gateway"",""host.name"":""api-server-03""},""severity"":""INFO""}" | "{""service.name"":""api-gateway"",""host.name"":""api-server-03""}" |

To extract from a top-level JSON array, use a bracket index on the root element:

```esql
ROW json = """["a","b","c"]"""
| EVAL val = JSON_EXTRACT(json, "$[1]")
| KEEP val
```

| val:keyword |
| --- |
| b |

Dot notation, array indices, and object keys can be combined to navigate deeply nested structures:

```esql
ROW log = """{"trace":{"spans":[{"name":"auth","events":[{"type":"start"},{"type":"end"}]},{"name":"db","events":[{"type":"query"}]}]}}"""
| EVAL event = JSON_EXTRACT(log, "trace.spans[0].events[1].type")
| KEEP event
```

| event:keyword |
| --- |
| end |


